// RobotBuilder Version: 2.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// Java from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.

package org.usfirst.frc7586.Test2.subsystems;

import org.usfirst.frc7586.Test2.Robot;
import org.usfirst.frc7586.Test2.commands.DrivewithXboxController;
import edu.wpi.first.wpilibj.livewindow.LiveWindow;
import edu.wpi.first.wpilibj.command.Subsystem;
import edu.wpi.first.wpilibj.Encoder;
import edu.wpi.first.wpilibj.Joystick;
import edu.wpi.first.wpilibj.PIDOutput;
import edu.wpi.first.wpilibj.PIDSource;

import com.ctre.phoenix.motorcontrol.FeedbackDevice;
import com.ctre.phoenix.motorcontrol.can.WPI_TalonSRX;
import com.ctre.phoenix.motorcontrol.can.WPI_VictorSPX;
import com.ctre.phoenix.sensors.PigeonIMU;

import edu.wpi.first.wpilibj.SpeedControllerGroup;
import edu.wpi.first.wpilibj.Talon;
import edu.wpi.first.wpilibj.XboxController;
import edu.wpi.first.wpilibj.GenericHID.Hand;
import edu.wpi.first.wpilibj.drive.DifferentialDrive;

/**
 *
 */
public class DriveTrain extends Subsystem {

    private WPI_TalonSRX talonSRX1;
    private WPI_VictorSPX victorSPX1;
    private SpeedControllerGroup speedControllerGroupLeft;
    private WPI_TalonSRX talonSRX2;
    private WPI_TalonSRX talonSRX3;
    private SpeedControllerGroup speedControllerGroupRight;
    private DifferentialDrive differentialDrive;
    private PigeonIMU pigeonIMU;

    public int autoRoutineNum = 0;
    private double minv = 0.4;
    private double maxv = 0.6;
    private double drift = 0.05;
    private double speed, steering, mod, r;

    public DriveTrain() {

        talonSRX1 = new WPI_TalonSRX(2);

        victorSPX1 = new WPI_VictorSPX(5);

        speedControllerGroupLeft = new SpeedControllerGroup(talonSRX1, victorSPX1);
        addChild("Speed Controller Group Left", speedControllerGroupLeft);

        talonSRX2 = new WPI_TalonSRX(1);

        talonSRX3 = new WPI_TalonSRX(3);

        speedControllerGroupRight = new SpeedControllerGroup(talonSRX2, talonSRX3);
        addChild("Speed Controller Group Right", speedControllerGroupRight);

        differentialDrive = new DifferentialDrive(speedControllerGroupLeft, speedControllerGroupRight);
        addChild("Differential Drive", differentialDrive);
        differentialDrive.setSafetyEnabled(false);
        differentialDrive.setExpiration(0.1);
        differentialDrive.setMaxOutput(1.0);

        talonSRX2.configSelectedFeedbackSensor(FeedbackDevice.CTRE_MagEncoder_Relative);
        talonSRX3.configSelectedFeedbackSensor(FeedbackDevice.CTRE_MagEncoder_Relative);

    }

    @Override
    public void initDefaultCommand() {

        setDefaultCommand(new DrivewithXboxController());
        // Set the default command for a subsystem here.
        // setDefaultCommand(new MySpecialCommand());
    }

    // Put methods for controlling this subsystem
    // here. Call these from Commands.
    public void takeXboxControllerInputsToTankDrive(XboxController a) {
        differentialDrive.tankDrive(a.getY(Hand.kLeft) * 0.7, a.getY(Hand.kRight) * 0.7);
    }

    public void takeXboxControllerInputsToArcadeDrive(XboxController a) {
        speed = Robot.oi.controller.getY(Hand.kLeft);
        steering = (Robot.oi.controller.getX(Hand.kRight) + 0.1 * speed) / 1.3;
        differentialDrive.arcadeDrive(speed * 0.7, steering);
    }

    /*
     * public void regularDrive() { sp = Robot.oi.controller.getY(Hand.kLeft);
     * steering = (Robot.oi.controller.getX(Hand.kRight) + 0.1 * sp) / 1.3; //if
     * (!isDrifting()) differentialDrive.arcadeDrive(sp * 0.7, steering); }
     * 
     * public void moderateDrive() { sp = Robot.oi.controller.getY(Hand.kLeft);
     * steering = Robot.oi.controller.getX(Hand.kRight); //if (!isDrifting()) { mod
     * = minv + maxv * (Math.pow(1 - Math.abs(sp), 2)); r = Math.pow(steering, 3) *
     * mod / 1.2; differentialDrive.arcadeDrive(sp * 0.7, r); //} }
     * 
     * public void simpleDrive() { sp = Robot.oi.controller.getY(Hand.kLeft);
     * steering = Robot.oi.controller.getX(Hand.kRight); //if (!isDrifting())
     * differentialDrive.arcadeDrive(sp * 0.8, steering); }
     */
    public void setSpeedControllerGroupLeftSpeed(double speed) {
        speedControllerGroupLeft.set(speed);
    }

    public void setSpeedControllerGroupRightSpeed(double speed) {
        speedControllerGroupRight.set(speed);
    }

    public double getAngle() {
        return pigeonIMU.getFusedHeading();
    }

    public void getAcceleration(short[] ba_xyz) {
        pigeonIMU.getBiasedAccelerometer(ba_xyz);
    }

    public int getLeftEncoderPosition() {
        return talonSRX2.getSelectedSensorPosition();
    }

    public int getRightEncoderPosition() {
        return talonSRX3.getSelectedSensorPosition();
    }

    public double getLeftEncoderVelocity() {
        return talonSRX2.getSelectedSensorVelocity();
    }

    public double getRightEncoderVelocity() {
        return talonSRX3.getSelectedSensorVelocity();
    }

    public void stop() {
        differentialDrive.stopMotor();
    }
}